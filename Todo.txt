*  Video cards / OpenCL support
 * Mike: NVIDIA geforce GT, 2gb mem
 * Eric: Amd but josh and Matthew have nvidia and I have physx card.  we have hd7950 a 470 gtx and a 480 gtx
 * Katie: going to test her 2 cards

TO "SHIP" TO TEAM
* give people access to the git repository and instructions on how to use it
* get people to try the exe

NEXT
* red blue 3d mode time!
* make the default.xml like it used to be (where it's a room w/ a pillar in the middle)
* convert testarea.xml too!
* V coordinate (of uv) is flipped for some sector walls.  likely fixed w/ a set U axis independant of texture uaxis.
 * can we make this the default if uaxis not specified in data too?
* find a way to make GetSectorPlaneNormal (and similar functions) only implemented in 1 place, instead of once in kernel and once in host
* make the offsets be easier to understand for "connect to portal" stuff.  like put it in world space or something
* "connect to portal" stuff needs portal window calculations done!
 * should be easy enough.  with no offset, you can get the window of each wall and just need to take the coordinates closer to zero for minx,maxx,miny,maxy.
 * with an offset, adjust the center of the windows accordingly and do the same thing!
* should portal windows be based on fixed / consistent U/Vaxis instead of the texture uvaxis?  this keeps things consistent (we can assume things in the code for portals) and makes it so portal windows are axis aligned
* make some kind of global connect to xml thing to make 2 way connections between sector planes.  maybe also specify whether the connection is 2 way or just 1 way?
* make shadows rays traverse sectors (PointCanSeePoint).  Currently just checks current sector
* make floor / cieling portals work (gravity won't let you fall through yet)
* better physics for player (and eventually other moving entities)
 * collision detection: walk on boxes, under objects, can't walk through walls?

* make the game generate documentation of data schemas -> for map files, gfx settings and game data
* map bulding and traversal
 -Have "connect" data nodes that make bidirectional connections between sectors.
 -All is needed is the plane index and point on each plane to connect to (in UV coordinate?) And it will handle the rest.  It will make the quad on each side for the 2 connections.
 -Maybe also want a one way hook up data node.
 -Also, should be able to generically make portals by hand.
 -Also, maybe all materials can be portals??? But only planes & quads can be walked through?

* make sector walls be able to cast shadows
* find a better way to enforce / handle sectors needing 6 planes, than doing an assert (error / skip?)
 * maybe also let the schema define a min and max size for the array so data parsing can catch it?
* somehow make portals contain dynamic geometry, or do some other dynamic geometry solution
* later: walk through any portal, not just sector walls
* later: only traverse portal if you walk through portal window.
* log error if "connectToSector" is given but it can't be found (same for other connect to stuff)





 
--MAP & GAME CONCEPTS
* at the lowest elevation point in the game, have a crack or hole in the ground or something where you can see the place supported by turtles, all the way down into infinity (maybe do some raymarching against the turtle shape or something)
* at the start of the game, enter a small house or something.  that thing contains the entire map.  After you beat the boss, you have to escape (timed? or maybe not).  When you escape, the object crunches down into nothing.

--RENDERING
* "deinterlacing" for the tear region?
* don't issue the undone work from C++ side when in interlace mode.  might be faster
* light cones in fog
* when you connect to another sector, have an option for copying / transforming lighting?
* formalize vector and matrix classes w/ math operators? or at least formalize API and make it easier to make code that is the same between kernel and host code
* particulates in the air somehow, affected by lighting but casting no shadows?
 * we could easily do something like have a function that we plug the x,y screen pos of the ray into to get a distance, and use that as a max distance (the distance that it hits the dust particle).
 * we could control density by controling the min / max distance possible of the particles
 * we could even animate it by adding some constant over time in X,Y,Z.
 * it's a problem if the camera moves though.
 * also a problem for secondary rays
* can we do volumetric fog as a material?
* directional light sources can be implemented as quads.  follow the direction backwards as a ray trace and see if you hit the plane (quad) or not.  could even do attenuation near the edges if wanted probably
* adding uv test to planes (to make quads) slowed everything down, even when no planes in scene. why?! (can test by removing feature and seeing if things speed up at all)
* teleport portals vs viewing portals
* command line param to start recording from the start (or a gfx option or something)
* if sector portals can only have a Y axis of 0,1,0,0 then maybe we can make a specialized matrix multiplication routine, and can also forgo even having a y axis?
* "interlaced mode": instead of rendering top / bottom half, try rendering middle half and then edges.  no seem in the middle, but 2 seems nearer to the edges
* "interlaced mode": try to blur the seems
* can we get a max intensity from the kernel code and put it through a compressor for brighten / darkening?
* maybe portals should specify rotation and translation instead of giving raw access to x,y,z,w axes?  maybe not, this is more powerful!
* dynamic object indices, similar to static objects.  When an object is in multiple rooms, duplicate it?
* figure out the right height for interlaced mode.  16 works well for me, but what about others?
* try making it so portals don't bypass the whole rendering process.  make it so they have an "amount" and contribute to the color, the same way reflection / refraction does.
* rename plane primitive to quad
* can try alpha (if even 1 bit).  if you sample a texture that has alpha, add to the color of the ray, multiply future ray colors by transparency amount, and keep ray going along current direction.  can not mix with reflection and refraction
* we can do procedural objects (just need bounding box or radius or something) and procedural textures too
* try making it so some things can be distance LODed, like bullet decals that are too far from the player or something.
* check out schlick's alternative to phong pow()
* could make material ID's be uint16 instead of uint32 if we want?
* decals as quads.  you shoot a wall, it sees where, makes a quad with a bullet impact image
* try generating kernel code that is tailored to geometry - since it has to be compiled at run time anyhow.
 * like have everything hard coded in there for static geometry, and only pass in dynamic geometry?
 * that would make it so different sectors could have different numbers of planes defining them
 * material data could also be hard coded in there, and texture data (??)
* "baked cache" -  if it's out of date (hash is different, non existant or whatever) it builds it.
 * can use this to do "bake time" operations as well.
 * could use this time to figure out average color of a texture, for "backup color" of objects for when textures are off!
* oriented shapes
* BSPs for polygonal models? (model loading too)
* could try something besides portals for rendering - like bsp with ropes or something.  KD trees.  bounding volume hierarchies (bvh)
* look into processing rays in packets?
* cloth physics & smooth interpolate the verts of the cloth?
* maybe material should have texture scaling instead of object.
* can we put off calculating some collision info things until we have our final object? like normal and texture coords
* we could do back face culling for objects that aren't transparent (esp planes)
* smoothish bump maps + reflection shows how the bump maps are somehow inherantly fucked up
* bump mapping doesn't look quite right... something is wrong with it.
* get full screen working
* why dont things show up when reflected on something that is pure white? it looks wrong...
* when something is black, it still reflects full on, which looks weird sometimes
* we need to look at having "reflection color" instead of reflection amount.  same for other "amount" things?
* make a fallback for when graphics options are off? like if no textures, set the diffuse color to something to aproximate it?
* try specular textures
* try refraction index textures?
* you get really neat effects if you texture things with the same texture you are rendering to!
* weather effects like rain and snow and fog
* some cool raytracing features: http://srodal.blogspot.com
* beers law for absorption of color over distance while light travels through it
* distance fog & volumetric fog
 * better fog: http://www.iquilezles.org/www/articles/fog/fog.htm
* skybox or skysphere? (eventually could do raymarching for terrain but ::shrug::)
* try animated bump mapping textures.  like for water droplets running down glass, or tentacly bio bumped stuff
* texture to control transparency and specularness etc.  try the things out.
* twist and manipulate camera rays. static and over time
* verify that specular calculation is correct
* verify that reflection calculation is correct
* verify that refraction calculation is correct. i think raytocameradir is wrong
* verify ambient light is correct... should it be used as many places as it is?
* verify that colorMultiplier is used correctly.  passed to apply light, but then also applied to result?!
 * should bail out if it gets too small?
* red blue 3d mode, toggle with a key
* it seems like reflective objects that have sections in shadow vs light should somehow not reflect as strongly in shadow?  might be ok actually though
* should we try having objects that don't RECIEVE shadows? not just ones that don't cast them... should be easy, they just don't do shadow test.
* try light attenuation over distance
* trybump mapping and other usages of textures to modify things per pixel
* add some randomness to specular / diffuse coloration to get rid of the banding.  graphics option for this?
* figure out a way to do reflection AND refraction (as a graphics option or something)
* can we bake lighting at all? bake in bsp somehow
* can we enable vsync?
* depth of field / bokeh
 * depth of field is some kind of ring for the source of the rays, can we set that up instead of doing multiple samples like everyone else does?
* use a compressor or limiter for brightness of scene?
 * would need a quick way to get scene brightness
* texture lookup for opacity, reflectiveness, refraction index and something else? (could pack 4 values per pixel in)
  * alternately, could let people specify a texture for those various things.
* directional lighting support later.  need to basically shoot a ray in the reverse direction towards infinity.  need to know the extents of what to test to make directional lights work so leaving it out for now.
* see what other kinds of RT effects there are out there besides what's implemented... ask around if needed?
* interlaced mode if needed as a faster rendering option
* red/blue 3d mode (screen door render if needed)
* dispersion / aberation investigation
* investigate depth of field.  people say you have to cast multiple rays, but maybe you don't if you configure the ray sources correctly?
* look at generating permutations based on object properties for faster, more custom fit code?  like call a function CubeIntersect_TextureNormal_TextureSpecular()
 * gotta watch out for instruction cache problems though...
* when doing normal mapping, it's crossing against (0, 1, 0) which doesn't work for flat surfaces.  need to figure out how to fix that.
* decal textures? both diffuse and normal maps, maybe other kinds too
* investigate iridescence
* rainy sidewalks have a reflectivity texture map
* rainty/watery window has animated normal map on refractive glass
* could mess w/ fish eye lense by changing the "camera distance" to a less good value
* oriented objects can be sphere tested as a first step, since they will have a set radius where the farthest corner sticks out.


--GAMEPLAY
* maybe "named dynamic objects" list to more quickly find named objects?
* friction (and slipping), varying gravity, jump pads
* revisit fixed game rate code (currently commented out)
* jumping has diff heights at diff frame rates (same with physics stuff in future!)
* jump doesnt always work, when in "fixed game time" mode, since that just checks space bar status, but might have missed one. (problem in recording)
 * should fix, its broken in non fixed game time too, but just not as bad
 * its now kinda bad too. you can hold down space and keep jumping
* hold shift to sprint.  walk / sprint speed in game data

--ARTIFICIAL INTELLIGENCE
* keep it simple
 * melee and ranged attack (each is optional)
 * different animations
  * walk animation
  * melee attack
  * ranged attack
  * death animation
  * take damage animation
 * walking speed
 * preference for melee vs ranged attack
 * walk or fly
* navigating 
 -short distance - navmesh in each sector?
 -medium distance - cost on each sector to go from each sector's portal to each other sector's portal.
 -long distance - ?? not sure if needed, but if we have a lot of sectors, A* across sectors may be too much

--GFX SETTINGS
* move default map from gfx settings to game data
* assert that ConeAttenuationAngle <= ConeAngle in point lights (or log an error)
* make graphics settings load more forgiving of load failure (currently sets resolution to 0,0). doesnt use xml defaults, but it probly should!
 * same with game data
* make graphics settings xml file generate if it doesn't exist
 * same for game data xml file
* max ray bounces setting
* graphics settings to allow reflection and refraction or not. With it off, reflection does nothing, and refraction doesn't change path of ray (so it's just transparent)
* put m_viewWidthHeightDistance etc into graphics settings
* let maps turn off gfx settings.  AKA if a map doesn't have any refraction, no need to test for it so turn off the setting.
* maybe sometime if a texture is lower resolution that our texture setting (like if it's 256x256 and our texture size is 512x512) we can put multiple onto one sheet somehow?  texture coordinates would need to be fixed up somehow
* window size as a graphics option
* figure out a decent number to choose for max textures, or make it dynamic in the future or something?
* graphics setting for whether to use mips for textures or not? currently no mipmaps used
* graphics option for texture size if doing a 3d texture to hold all the textures, since they have to be the same size
* graphics option for vsync.  if vsync is on, it will pass (1, 0) to  m_pSwapChain->Present
* use +/- buttons to increase and decrease render quality (actually maybe just do low, med, high since it needs to recompile the kernel code for each one!)
* make the max # of textures be a graphics setting?
* graphics setting for texture sampling options? (linear vs nearest? although it's weird with 3d textures since the other texture shows through)
* xml file to describe graphics options for now?
* gamma setting
* if no reflection or refraction from #define settings, remove loop completely.
* make an xml settings file and pass those as #defines to the compiler thing?
* have some way to do autodetection of graphics settings?
* pass graphics settings as #defines to kernel code


--GAME SETTINGS
* mouse sensitivity / invert mouse settings


--DATA SCHEMAS
* make it error when an id is not found, that is referenced from data.
* make a templated data link type class
* make Field_Schema default work for more than just xml loading.
* C# property grid for generic data editor?
* make the game spit out documentation for the schema files (put hint text into schema and field definitions)
 * maybe done via generic xslt script or something, so other things can tie into it too?
* data parenting support.  "my parent is this, so use everything from him, and over-ride with these values i specify!"

--KERNEL CODE
* instead of kernel code checking for indices being in range, going to make it the responsibility of the CPU to not pass bad data. more dangerous but less kernel code & memory usage etc

--CODE
* texture manager likely doesn't need STexture2d struct since it doesn't use a lot of the fields
 * similar for cdirectx....
* load images in another thread or something?
* make it so we don't update the global root each frame, only when the data actually changes.  That will keep it "cleaner" more often hopefully.
 * maybe have a shared object struct where things are updated every frame (like, camera position) and another where things are seldom changed?
* #pragma warning ( disable : 4005 ) // fix this eventually
* is it better to send the shared data root to kernel as a pointer?
* some command to reload a map file? (like, pressing R?)
* handle the warnings under the code analasys option under the build menu
* improve the video recording quality
* make the recorded video frame rate be specified in data somewhere
* put crouch heights and blend time in some kind of data catalog
* if the window doesn't have focus, i think we shoudl make it sleep (multiplayer?) or just not do rendering (as often?) or something.  it eats up a ton of cpu otherwise
* should we prevent the issue of moving diagonally being faster?
* should there be so many static classes? i kinda think not, or they should have real singleton interfaces
* make asserts show their failed assert? (can do #x in a printf maybe?)
* should we abstract a hotkey system?  we should properly "refcount" key downs and ups, but key repeat kinda screws that up so need to figure that out.
* if needed, could break code up into multiple projects to help compile time if it ends up being an issue
* CDirectX.cpp / .h needs some cleaning up
* if making a data catalog, allow it to be used for network messages as well
* make a way (a script for example) to make a publishable build (grabs exe, shared code, kernel code, etc and puts into some folder and possibly zips it up or whatever?)
* some way to trigger a map reload (need a console?)
* verify material index is in range before indexing in kernel somehow.  maybe have material zero be the default / error material?
* do something to make kernel code build errors more obvious, since it exits now before you can read it. like sscanf on build error or something? idk
* put asserts where needed
* alt+enter full screen toggle (or at least graphics option)
* better app title for window?
* test device lost if still relevant
* can we do any cpu stuff while waiting on gpu?
* quaternion camera?  polar coordinate camera may actually be enough.  quaternion would only be needed for flight controls etc
* attempt to run it on cpu only? might be super super slow, but may be ok at low resolutions and graphics settings?
* async build of cl scripts... you pass a function pointer to clBuildProgram, it will do this
* oclCheckErrorEX <-- go away!!
* can we hide kernelcode/shared include files in the exe or encrypt somehow or something?


--OPENCL INVESTIGATION
* could pass a random number, or hash of all relevant files, to the CL compiler as a #define, so it would recompile when needed
* is there a limit to what can be sent to the kernel as arguments? max size or max count?
* there is some way to get the capabilities of the system, we should probably use that to verify the things we are doing are ok
* if you change compile defines, will it recompile the script? it better!
* how do you profile opencl?
* review the querying and creation of opencl platforms, devices and contexts
 * make sure doing right and taking advantage of all options.  probably want a graphics option to choose device!
* see how to get CPU involved.  Maybe having it help would be useful too? dunno.
 * maybe end user can choose device it runs on somehow...
* is it running in SLI? how can i check
* figure out optimizations for kernal (check link in notes).  like maybe do full opts in release mode or something?
 * make denormals zero! and other nice things


--BUGS
* mouse input doesnt work in 64 bit build
* build warning about: c:\program files (x86)\microsoft directx sdk (june 2010)\include\dxgitype.h(12): warning C4005: 'DXGI_STATUS_OCCLUDED' : macro redefinition

--PROFILING
* can you somehow precompile kernel so you dont have to worry about packing and paddnig and shit?
 * appaerntly yes, but it makes it too device specific.  investigate
* make a way to show how many ray bounces per pixel for profiling purposes
* also show how many object tests per pixel (whiter dots = more)


--MODELS
* animated meshes: Have it make bsp trees for each pose?


--LUA
* lua binding so can use this thing from lua and make lots of diff games.
 * is there a way to protect the lua / opencl or embed it into the exe or something?
 * lua swig or lua bind (bind not as good apparently)






=====NOTES=====
? is there an instruction limit in opencl?
 * not really but you dont want to make it too large since the instruction cache is like 64KB usually.
 * http://devgurus.amd.com/thread/158542

* clBuildProgram notes (includes, optimizations, etc)
 http://www.khronos.org/registry/cl/sdk/1.0/docs/man/xhtml/clBuildProgram.html

* it doesn't seem to recompile the cl program unless you modify the cl itself, you can't just edit a header it includes and expect it to recompile! (shitty).
 * also, it doesn't go off timestamp, but actual changes, so you literally need to add a new blank line or something for it to recompile

* when packing a 3 vector and a scalar into a float4 be careful... operations on the 3 vector will overwrite w! you have to do it like this below.  may not be particularly safe... but it does pack things tighter, so tough to say we shouldn't do it at all
 (*(float3*)&info->m_intersectionPointAndTime) = rayPos + rayDir * collisionTime;
 info->m_intersectionPointAndTime.w = collisionTime;

* could use address of primitive instead of having to have an ID per primitive
 * no - for some reason when i did that it went from 400fps down to about 70fps.  no idea why

* RT Basics Done
 * shadows
 * sphere primitives
 * specular lighting
 * diffuse lighting
 * ambient lighting
 * point light
 * box primitives
 * reflection
 * max raybounces
 * refraction

=====DONE=====

--1/27/14
* worked on getting sector plane "connect to" working

--1/26/14
* working on making ConnectToSector stuff work in sector plane definitions
 * pretty close to working... for the "square" room, one link was working, but the other wasn't

--1/25/14
* distance attenuation for lights
* put in real spot light function
* graphics setting to turn off high quality lighting (distance and angular attenuation)

--1/23/14
* camera is transformed by portal when traversing sectors now
* make StartFacing a float3
* make lighting seemless in default.xml

--1/22/14
* seperate maps from settings and game data
* rename sharedmath.h and take it out of the shared folder, since it isnt, and can't be shared

--1/20/14
* made it so you walk through portals to change sectors.  doesnt check against portal windows though
* made a more complex, looping / non realistic infinite map

--1/15/14
* put all geometry into sector definitions.
 * move other geometry types in
 * also point lights
 * ambient light
* might not need "numplanes" etc, if the indices to use are part of sector data

--1/14/14
* put planes into sectors.  will move the rest of geometry types, and give shadow treatment later
* interlaced mode, via graphics setting and #define to kernel code

--1/12/14
* added quad support
* made planes be able to define dimensions -> a min/max u,v to be considered as a hit.  IE quads are supported now
* do compile time const asserts that the size of structs in shared object and shared array are multiples of 16
* portals are now a generic thing that any shape can use, not just sector walls, but sector walls have kept their "portal window" field because it's more efficient than having a seperate plane when a portal is on a sector wall anyways
* basic interlaced mode implementation
* added gfxsettings.xml and gamedata.xml

--1/11/14
* made sectors into AABBs defined by just width, height, depth.  kept per plane material etc.  portals are still a sector wall feature for now but will change soon.

--1/5/14
* started formalizing an ID system for the data catalog.
* started making it so sector walls could be see through & lead to other portals
* enforce unique ids in data items that have ids
* make it so portal walls can define a UV square for the portal, and it uses the material info for the rest of the box.
* make sector walls each have their own id so reflection of sector walls works correctly

--1/4/14
* started working on portal rendering.
* you can define sectors, and the game tells the renderer which sector the camera is in.  it only tests rays against that sector

--12/13/13
* continued work on plane primitive for bsp

--12/12/13
* added plane primitive in preperation of BSP, some work left to do

--12/10/13
* fixed timestep logic - so you dont have times that you can jump higher etc
* made collision info contain surface normal as well as U and V vectors

--11/17/13
* finished getting bump maps working
* got emissive texture working
* make sure all cl_mem objects are getting released properly with clReleaseMemObject

--11/16/13
* been working on textures, got it working as a 3d texture.  textures need to be square, but they are bilinear filtered to the appropriate texture size.

--11/13/13
* got formalized schema based xml parser done... been working on it on and off the last several days
* organized and cleaned up the code a bit
* got jumping and gravity working
* got crouching working
* got video recording and screenshots working

--11/4/13
* command line to load a specific xml scene file so people can make their own maps
* got 64 bit build working, although mouse input doesn't work in debug or release in 64 bit

--11/3/13
* over the weekend learned a ton about matrix math
* got bumpmapping w/ RT working on shadertoy.  looks amazing combined with refraction
* got code into git

--10/29/13
* got most of xml scene loading working

--10/26/13
* got shadows working
* only shadow test objects marked as casting shadows
* move ambient lighting to be a c++ param
* make the light spheres use a material that is their color
* use constant instaead of global space
* combine color and amount, pos and radius etc.  use swizzle to get just the components you want.  shared geometry / smaterial
* make sure all params are out of the kernel code

--10/25/13
* made more objects be passed through from c++ side
* made materials be a set of objects indexed by prims
* fought w/ padding and alignment w/ shared structs working for now (need to formalize it later to be not manual)
* make some kind of shadowed object array to make it easier to send objects to the cl file.

--10/21/13
* swept the crash on exit under the rug by not dynamically unlinking dx10 at exit.  todo for later :/
* lights now get passed through dynamically from cpp

--10/20/13
* got a basic camera in as a shared struct passed to the kernal
* got some spheres with specular, diffuse and ambient lighting in.  got a point light in
* got wasd movement and mouse look in
* axis aligned box support
* reflection / refraction
* got rid of nvidia extensions in favor of khr extensions of the same name

--10/19/13
* figured out how includes and defines worked in .cl program compiling
* cpu gives camera pos, fwd, up and other info and passes it to cl to make into rays.
--9/22/13
* Get opencl compiling and running
* started cleaning up and renaming things