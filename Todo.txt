NEXT

* SLI on / off doesnt seem to matter... figure out how to use both video cards!!

* save off the current physics as a "free fly" mode?

* make the physics cylinder be able to traverse sectors
* a cylinder may be in multiple sectors at once, need to deal with that.

* make physics & sector traversals work in ECS system, the right way that it should work

* make "player height" work again, instead of the camera being in the center of the cylidner.
 
* solve the problem of how components should interface with the world (like, for physics!)
 * maybe also need a separate system for physics world, so ECS doesn't need knowledge of shared array and shared geometry stuff
 * Systems.cpp also shouldnt be including and interfacing with ECS namespace!!
 * apparently we need a singleton entity with singleton components

* make sprinting, crouching and jumping work. make sure all current functionality works.

* "left" isn't really the right term, it's really right...

* can we run the game logic during the render? possibly on another thread?  try it and see.  can simulate longer game loop with a sleep or something.

* remove math stuff from camera class after making component work, since camera just gets transform from entity.  math stuff should be in a global place for all transforms.

* if we can formalize a way to get outside resources into the ECS system, we could let the camera system get write access to the camera from another thread.

* maybe need another component for "desired movement".  or maybe it should go into the "bearings" component?

* when consuming the data from the input component (mouse move...) reset it back to zero?

* find another word for bearings.

* get rid of cplayer class - should be replaced by components!

* get rid of auto adjust brightness. games fake it!

* instead of ECS coupling mouse input so directly with CCamera, should have mouse input change rotation on entity, and should have camera take that info after ecs tick or something?

* helper function for creating entities? just pass in entity ID.  perhaps should be in CGame

* look into enum classes for a templated flags class!
 * we may not actually need these flags / enums if we change where CreateEntity() lives
 * still useful in other times i'm sure -> like with input flags

* moev the player creation out of load game data, into something else. like init world or something? who knows

* game data probably should be loaded before the world is loaded - and kept around all the time, as you go from level to level.

* find a way to wrap access to all ECS externals (like CCamera) into some kind of "shared resource" system, so that only one person can have write access at a time etc.
 * CCamera needs this for sure!
 * also, how we get the input component list inside ECS for input to propogate input, that isn't safe


* antialiasing
* temporal supersampling for AA
* iterative BVH tests
* depth of field (?)
* motion blur (?)


* figure out a better way to automate more of the bearings and ECS hookup boilerplate code

* take start position and related data out of level since it's specified in the player component?
 * maybe we need to have level data override that though! it makes sense to be set per level :/

? how does the camera system communicate with the rest of the game?
 * maybe data storage fields are defined in the system list for the camera settings, and those are coppied by CCamera or whatever?
 * maybe the system communicates directly with CCamera, so that script can do that as well later on?
 * or maybe both.  if camera system is enabled (has an entity plugged into it), the main game loop takes data from the system and passes it onto CCamera
   * if the system is not enabled, it doesn't. script would then be able to control it at this point

* automate updating of the defined systems   

* ECS: enforce SYSTEM_SINGLE / SYSTEM_MANY in entity registration

* Find a better place for the world object to live, than on the directx object!! maybe global singleton

* for ECS systems, could have a way to specify if all entities and components are needed at once, or if it's ok to be passed them one at a time.
 * if one at a time, could do across multiple threads.
 * if all needed at once, need the caller to gather them all and send them over.

* only one entity can use the camera system at once. can you add / remove entities from systems?

* systems may need to specify "resources" they need access to, like input, camera, physics world... ::shrug::

entity type:
 * Systems that apply to it
 * component list is implied by union of components needed by systems.
  ? data or macros??
  * components need initialising.
  * systems probably also need some sort of data parameters or something

ECS details
* Entity types are defined in data and have an array of components they contain
* Components are defined in code and belong to an entity
* Systems are defined in code and specify what components are required to be processed by a specific system, and whether they want read only or read/write access
* Other details:
 * Systems are processed in the order that they are defined (or, could have a sequence number perhaps)
 * Each system has a list of entities that it does work on.
 * when an entity is created, it registers with the appropriate systems
 * when an entity is destroyed, it removes itself from the appropriate systems
 * need some kind of scheduler to run systems multithreaded in a safe way, in the prefered order
 * maybe entities need to opt into systems? maybe components on an entity are defined by which systems it opts into?

* ECS (entity component system) model with built in threading scheduling.  Entity, Component, System

* get rid of connect sector stuff? dont think it's going to be used

* make it so you can't get close enough to walls to see through them.
 * there is a distance from camera to the view plane, maybe we have the view plane be at zero, and move the camera back?

* make floor / cieling portals work (gravity won't let you fall through yet)
 * hopefully fixed when going to component system

* make it so jumping isn't frame rate dependant

* better physics for player (and eventually other moving entities)
 * collision detection: walk on boxes, under objects, can't walk through walls?
 * hopefully fixed when going to component system

* only traverse portal if you walk through portal window.





* integrate lua
 * interact with objects by id
 * change light params etc
 * AI programming?
 * ability to have threaded lua calls?

* record a video of some animated objects (moving / expanding contracting, rotating, etc) and absorption objects etc.  fog and moving lights





--ECS Entity Component System
* better error if a system can't get a component that it needs by ID.
* make component get by id use binary search, or have some way of letting the system start from where it was last time when looking for the higher entity id.
* do we need a way to order the updates of the systems, instead of them just being in the order they are defined? or is that ok?
* log an error if we can't create the player entity
 
--MAP & GAME CONCEPTS
* can use blue fog for underwater look
* can use white fog as "god rays"
* at the lowest elevation point in the game, have a crack or hole in the ground or something where you can see the place supported by turtles, all the way down into infinity (maybe do some raymarching against the turtle shape or something)
* at the start of the game, enter a small house or something.  that thing contains the entire map.  After you beat the boss, you have to escape (timed? or maybe not).  When you escape, the object crunches down into nothing.
* could do something like you step through a mirror into a sector that is a reflection of the sector you came from, but leads to different sectors.
* could have underwater stuff i think with swimming.
* could mess with camera view to have trippy effects.  Both simple stuff like changing fov, but also more complex stuff like sine wave offsets of primary ray directions
* could use a distance field texture for symbols on walls.  high specular with multi color (specular color or multiple lights?) probably would look pretty cool
* show a monster for the first time behind frosted glass
* bump mapping a reflective floor can make a neat "blurry when farther away" effect

--MODELS
* version number in MDX files
* can you split the triangles up by more than just +/- y? Can you do like 10 slices??
* blender has other textures available that we could use if we want: ambient texture (?), specular map, hardness map (?), reflection map, alpha map, translucency map (?), bump map
* models need to be able to export / load reflection and absorption
* need to make blender exporter export the casts shadows flag that is exposed (somewhere) in blender
* are there too many duplicate materials being created?
* how does bitangent sign work? data in blender
* make artist notes so artists can do work
* could do both bounding sphere AND AABB test if that would help non spherical models :P
* if splitting y axis more than into 2 sections, could instead do N slices, and keep track of where each slice ends index wise. then, find the min/max index of the ray and do the corresponding slices.

--RENDERING
* static shadows for static geometry and static lights - somehow, not sure.
* neat effect: set bearings.m_rotationAxisZ to 0,0,1 but let the other axis rotations happen. could be a neat drunk / dazed effect.
* tile rerendering may actually help here? well... how often will the camera not be moving though...
* try implementing "flip quad" supersampling. or flip tri
 * basically, every even row samples left side high on even frames, then left side low on odd frames.
 * every odd row samples top side left on even frames,  then top side right on odd frames.
 * these sames can be used by both cells that touch the sample effectively giving each cell 2 samples for the cost of 1 sample.
 * if you compost current frame with last frame, you basically get 4 samples for the cost of 1.
* exponential fog
* glitter and related articles:
 * http://gamedev.stackexchange.com/questions/69011/how-can-i-create-a-glitter-effect  
 * http://developer.amd.com/wordpress/media/2012/10/Shopf-Procedural.pdf
* do color thresholding to make image look "old".  might be a special effect when you have a specific status or something.  or for in game cinematics or something..
* make a gfx option for smoothing on distance field textures or not? or maybe just always turn it on.
* need the ability to specify a vaxis for the sector planes.  if non specified, derive it from vaxis.  needed cause you can't orient textures the way you want always (like, to make text look right)
* definite integral to find out fog amount of fog density defined by f(x,y,z) for 2 end points of a line segment A, B
* if doing "varying fog densities" like with a perlin noise fog density function, "ray march" down the ray doing fog samples, making the step get progressively larger as distance increases (distance down ray? or distance from camera??)
 * also could look at calculus and convolution stuff.
 * maybe do it independantly per axis to simplify it and then add the results together?
 * i wonder if sine waves might be able to do something special here because area under sine wave is cosine wave and such
* somehow make portals contain dynamic geometry, or do some other dynamic geometry solution
* gfx setting to limit frame rate to a reasonable amount (on by default)
? when instancing model triangles, they share object id's.  is that what we want? might need to think about having a "base index" or something.
? could try "hard coding" stuff for perf so long as it's ok that things aren't destroyed.  for instance, the number of models in a specific sector.
* maybe we need a thing where portals have a color multiplier applied to what they show.  maybe we need a "portal" mode to go along w/ reflection and refraction enum?
* when we hit a triangle, is there a way we can put off filling out the bulk of the collision info things until we are done, so we do less redundant work? (if it would even be a win... need to profile)
* mess with camera rays, to do effects like "underwater distortion" and such. cool underwater effect: https://www.shadertoy.com/view/4dXXzB
* could try testing models front to back based on bounding sphere collisions
* subsurface scattering investigation - need depth penetration of light through object, which could be gotten as part of shadow calculation work
* can blend between 2 textures easily (either animated in real time, or statically like multi texture) since it's 3d texture.  just use some texture coordinate between the 2 frames
 * both for textures as well as normal maps!
* should fog be affected by light somehow? like find out how much of the fog is in a light source and change fog color or something?
* non uniform scaling
* let fog be a material property so we can have objects that have fog in them
* dominic said 256x256x256 is general an ok 3d texture size
* look into -threads parameter of ffmpeg, and also see about writing all frames to a single file.
* make a gfx setting for video path, so could write to a non os drive if wanted.
* check out the "select" function thing for the DEBUG_MODEL_BOUNDING_SPHERE code
* make sector walls be able to cast shadows (does that make sense?)
* make shadows rays traverse sectors (PointCanSeePoint).  Currently just checks current sector
* if making shadows traverse sectors make shadows more expensive, could have a shadow quality setting: off, low (current), high (traverses sectors)
 * and another high level for transparent shadows
* maybe need to think about this a bit more.
 * It could be done by just instancing the objects, or by considering neighboring sectors explicitly.
 * this is kind of what we want to do for lighting anyways.
 * maybe need some kind of "cross sector awareness" solution besides traversal?
* adjust FOV or whatever else needed when aspect ratio of resolution doesn't match the display when in full screen mode
* exposure time (limiter for light! i think it will look bad ass!)
 * figure out how other games do exposure time
 * per level settings for "expore time adjustments"?  I want to turn it off sometimes, but it shouldn't be a graphics setting
 * max pixel isn't doing it... need to average or something
 * formalize a system (in the camera?) for brightness adjustment calculations
 * graphics setting for bloom or not
 * could do bloom blur with a single float precision buffer of "gray"s
 * how is bloom going to work with red/blue 3d and interlanced mode?
 * how is "max brightness" going to work with interlaced mode? like if the bottom of the screen is super bright but the top isnt
* if hdr exposure time adjustments are part of gameplay, need to make it dependant on the frame rate as little as possible
 * atomic max of brightness calculation hurts FPS a lot.  do it every x frames perhaps? or find a better way.  maybe DX api call to resize texture to 1 px and read that pixel?
* at work, its red/green not red/blue when 3d is on.  need to somehow query surface format or something?!
* beers law absorption - need to calculate on CPU side what the starting absorption color is based on what object the eye is in. otherwise it doesn't look right when you enter a shape
* don't do shadow ray if dot product is negative? (and backface culling is on)
* skeletal animation: loading and runtime
* could have bias parameter to height fog saturation instead of making it linear
* could try having light interact with fog
* unify reflect, refract code if we can
 * could unify the reflect/refract data a bit better.  data specifies "reflect", "refract" or "none".  one color stored for color parameter.
* probably faster to get screenshots for making video from GDI, not dx
? can we do a switch statement instead of "if reflective, else if refractive, else"? might be more paralelizable
* try IQ's thing of doing ray vs camera-to-lightsource dot product, and colorize fog based on that value
* can use angled white fog as "god rays"?
* when hitting an object from the inside, we don't do fog.  that is good but not 100% correct.  we shouldn't do fog if we are INSIDE an object.  we should maybe have an "inside object" count that we inc / dec as we enter and leave objects, and do fog if the count is zero
* IQ fog: http://iquilezles.org/www/articles/fog/fog.htm
* could try having scaling on sector/portal transforms
* should we change 4x4 matrixs from four cl_float4's to one cl_float16?
* is the sector's "CastShadows" flag even used? probably should get rid of it i think? maybe it could be used... but how?
* try simpler, quicker geometry tests for shadow tests
 * not usable by transparent shadows though ):
* try softmax for melding shapes?
* there are cracks in meshes.  watch a icosphere in front of a back background, and you'll see a couple bright dots poke out as you move around
* try billboarded models that orient themselves based on the incoming ray orientation? (or camera orientation perhaps... dunno.  what happens for reflections)
* transparent shadows
* try interpolating normals across a triangle?
* don't need to really store m_halfSpaceFlags permanently on triangles, that is just used for sorting.
* did some "half space flags" to try and cull triangles from tests, didn't seem to help. made it slower in fact!  i had 6 flags for whether the triangle / segment was in posx, negx, y, z, and & the flags together as an early out for the triangle
 * try just vertical axis separation in the future, sorting the triangles so it's a different starting / stopping index instead of a per triangle test

* back face culling seems to slightly slow things down very slightly
 * is it programmed in some way that is not so great, like bad memory access pattern or something?

* initialize collision info max distance to max fog value, when fog is in effect?
* try having a "mirror axis" for models to save on polygon storage and possibly collision detection time.
* could have an offset to the "quadrant flags" origin so that you can put the origin in a place that is more balanced for numbers of triangles in each half space
* try making the quadrant flags actualy keep track of which quadrants are hit, instead of which half spaces are hit, and see if it makes that much of a difference for performance.
* skybox could be specifed on portal instead of in sector, so that you could have multiple skybox views looking out into the same sector from different locations
* cool procedural fractal texture that can animate: https://www.shadertoy.com/view/ldS3DK
* sphere test early out for bezier surface.
* ray march bezier surface if equations dont work out?
* try scaling objects by changing t factor for x,y,z axis
* could try 2d polygons on planes instead of triangles (maybe need less polys?)
* investigate "infinite rendering" through modulus or something with raytracing
* sparkly paint effect: https://www.shadertoy.com/view/ldsGzl
* ray march implicit objects that are in a bounding sphere that is raytraced?
* checking to see if we need to do the brightness atomic max in the kernel makes it drop from 92 to 87 fps for me even if it only actual samples every 500 frames.  maybe there's a better way to do it that's cheaper?
* HDR tech -> tone mapping, bloom (?) etc?
* it doesnt seem to keep same FOV when you change window size
* in 3d red/blue mode, the "teleport" thing for skyboxes makes the eyes in the same place, which makes everything lose depth.
* in 3d red/blue mode, its possible for the "other eye" to leave the sector and go black.
* if a sector doesn't have anything in it that casts shadows, maybe we don't even check for shadows? might speed things up, not sure
* later on (next game) don't make everything so "up oriented".  could make some really cool stuff! not sure if it should be a flight sim or what
* the calculation of portal window is likely wrong.  for some reason we have to invert the X axis offset...maybe because the "X walls" have u axis negated?
* "deinterlacing" for the tear region?
* don't issue the undone work from C++ side when in interlace mode.  might be faster
* light cones in fog
* when you connect to another sector, have an option for copying / transforming lighting?
* formalize vector and matrix classes w/ math operators? or at least formalize API and make it easier to make code that is the same between kernel and host code
* particulates in the air somehow, affected by lighting but casting no shadows?
 * we could easily do something like have a function that we plug the x,y screen pos of the ray into to get a distance, and use that as a max distance (the distance that it hits the dust particle).
 * we could control density by controling the min / max distance possible of the particles
 * we could even animate it by adding some constant over time in X,Y,Z.
 * it's a problem if the camera moves though.
 * also a problem for secondary rays
* can we do volumetric fog as a material?
* directional light sources can be implemented as quads.  follow the direction backwards as a ray trace and see if you hit the plane (quad) or not.  could even do attenuation near the edges if wanted probably
* adding uv test to planes (to make quads) slowed everything down, even when no planes in scene. why?! (can test by removing feature and seeing if things speed up at all)
* teleport portals vs viewing portals
* command line param to start recording from the start (or a gfx option or something)
* if sector portals can only have a Y axis of 0,1,0,0 then maybe we can make a specialized matrix multiplication routine, and can also forgo even having a y axis?
* "interlaced mode": instead of rendering top / bottom half, try rendering middle half and then edges.  no seem in the middle, but 2 seems nearer to the edges
* "interlaced mode": try to blur the seems
* can we get a max intensity from the kernel code and put it through a compressor for brighten / darkening?
* maybe portals should specify rotation and translation instead of giving raw access to x,y,z,w axes?  maybe not, this is more powerful!
* dynamic object indices, similar to static objects.  When an object is in multiple rooms, duplicate it?
* figure out the right height for interlaced mode.  16 works well for me, but what about others?
* try making it so portals don't bypass the whole rendering process.  make it so they have an "amount" and contribute to the color, the same way reflection / refraction does.
* rename plane primitive to quad
* can try alpha (if even 1 bit).  if you sample a texture that has alpha, add to the color of the ray, multiply future ray colors by transparency amount, and keep ray going along current direction.  can not mix with reflection and refraction
* we can do procedural objects (just need bounding box or radius or something) and procedural textures too
* try making it so some things can be distance LODed, like bullet decals that are too far from the player or something.
* check out schlick's alternative to phong pow()
* could make material ID's be uint16 instead of uint32 if we want?
* decals as quads.  you shoot a wall, it sees where, makes a quad with a bullet impact image
* try generating kernel code that is tailored to geometry - since it has to be compiled at run time anyhow.
 * like have everything hard coded in there for static geometry, and only pass in dynamic geometry?
 * that would make it so different sectors could have different numbers of planes defining them
 * material data could also be hard coded in there, and texture data (??)
* "baked cache" -  if it's out of date (hash is different, non existant or whatever) it builds it.
 * can use this to do "bake time" operations as well.
 * could use this time to figure out average color of a texture, for "backup color" of objects for when textures are off!
* oriented shapes
* BSPs for polygonal models? (model loading too)
* could try something besides portals for rendering - like bsp with ropes or something.  KD trees.  bounding volume hierarchies (bvh)
* look into processing rays in packets?
* cloth physics & smooth interpolate the verts of the cloth?
* maybe material should have texture scaling instead of object.
* can we put off calculating some collision info things until we have our final object? like normal and texture coords
* we could do back face culling for objects that aren't transparent (esp planes)
* smoothish bump maps + reflection shows how the bump maps are somehow inherantly fucked up
* bump mapping doesn't look quite right... something is wrong with it.
* get full screen working
* why dont things show up when reflected on something that is pure white? it looks wrong...
* when something is black, it still reflects full on, which looks weird sometimes
* we need to look at having "reflection color" instead of reflection amount.  same for other "amount" things?
* make a fallback for when graphics options are off? like if no textures, set the diffuse color to something to aproximate it?
* try specular textures
* try refraction index textures?
* you get really neat effects if you texture things with the same texture you are rendering to!
* weather effects like rain and snow and fog
* some cool raytracing features: http://srodal.blogspot.com
* beers law for absorption of color over distance while light travels through it
* distance fog & volumetric fog
 * better fog: http://www.iquilezles.org/www/articles/fog/fog.htm
* skybox or skysphere? (eventually could do raymarching for terrain but ::shrug::)
* try animated bump mapping textures.  like for water droplets running down glass, or tentacly bio bumped stuff
* texture to control transparency and specularness etc.  try the things out.
* twist and manipulate camera rays. static and over time
* verify that specular calculation is correct
* verify that reflection calculation is correct
* verify that refraction calculation is correct. i think raytocameradir is wrong
* verify ambient light is correct... should it be used as many places as it is?
* verify that colorMultiplier is used correctly.  passed to apply light, but then also applied to result?!
 * should bail out if it gets too small?
* red blue 3d mode, toggle with a key
* it seems like reflective objects that have sections in shadow vs light should somehow not reflect as strongly in shadow?  might be ok actually though
* should we try having objects that don't RECIEVE shadows? not just ones that don't cast them... should be easy, they just don't do shadow test.
* try light attenuation over distance
* trybump mapping and other usages of textures to modify things per pixel
* add some randomness to specular / diffuse coloration to get rid of the banding.  graphics option for this?
* figure out a way to do reflection AND refraction (as a graphics option or something)
* can we bake lighting at all? bake in bsp somehow
* can we enable vsync?
* depth of field / bokeh
 * depth of field is some kind of ring for the source of the rays, can we set that up instead of doing multiple samples like everyone else does?
* use a compressor or limiter for brightness of scene?
 * would need a quick way to get scene brightness
* texture lookup for opacity, reflectiveness, refraction index and something else? (could pack 4 values per pixel in)
  * alternately, could let people specify a texture for those various things.
* directional lighting support later.  need to basically shoot a ray in the reverse direction towards infinity.  need to know the extents of what to test to make directional lights work so leaving it out for now.
* see what other kinds of RT effects there are out there besides what's implemented... ask around if needed?
* interlaced mode if needed as a faster rendering option
* red/blue 3d mode (screen door render if needed)
* dispersion / aberation investigation
* investigate depth of field.  people say you have to cast multiple rays, but maybe you don't if you configure the ray sources correctly?
* look at generating permutations based on object properties for faster, more custom fit code?  like call a function CubeIntersect_TextureNormal_TextureSpecular()
 * gotta watch out for instruction cache problems though...
* when doing normal mapping, it's crossing against (0, 1, 0) which doesn't work for flat surfaces.  need to figure out how to fix that.
* decal textures? both diffuse and normal maps, maybe other kinds too
* investigate iridescence
* rainy sidewalks have a reflectivity texture map
* rainty/watery window has animated normal map on refractive glass
* could mess w/ fish eye lense by changing the "camera distance" to a less good value
* oriented objects can be sphere tested as a first step, since they will have a set radius where the farthest corner sticks out.


--GAMEPLAY
* use refraction in the gameplay somehow? like legend where you make light point at the bad guy? or maybe make a lazer hit a target
* if the camera adapts to light levels, could have a "close eyes" button to make your eyes adjust to darkness before going into a room?
 * could also do that to avoid flash bang effects and things (or if an enemy does a really bright "bedazzle" attack or something)
 * could then also have enemies which only chase you when your eyes are open.  You could walk through them and hear them, but as long as you kept your eyes closed, they wouldn't hurt you.
* when going into a "rage mode" could set cameraShared.m_viewWidthHeightDistance[2] to 1 (lerp to it)
* when going into a scope, could set cameraShared.m_viewWidthHeightDistance[0] to 1
* maybe "named dynamic objects" list to more quickly find named objects?
* friction (and slipping), varying gravity, jump pads
* revisit fixed game rate code (currently commented out)
* jumping has diff heights at diff frame rates (same with physics stuff in future!)
* jump doesnt always work, when in "fixed game time" mode, since that just checks space bar status, but might have missed one. (problem in recording)
 * should fix, its broken in non fixed game time too, but just not as bad
 * its now kinda bad too. you can hold down space and keep jumping
* hold shift to sprint.  walk / sprint speed in game data

--ARTIFICIAL INTELLIGENCE
* keep it simple
 * melee and ranged attack (each is optional)
 * different animations
  * walk animation
  * melee attack
  * ranged attack
  * death animation
  * take damage animation
 * walking speed
 * preference for melee vs ranged attack
 * walk or fly
* navigating 
 -short distance - navmesh in each sector?
 -medium distance - cost on each sector to go from each sector's portal to each other sector's portal.
 -long distance - ?? not sure if needed, but if we have a lot of sectors, A* across sectors may be too much

--GAME DATA
* mouse sensitivity needs to go into a setting somewhere
* seperate the schemas a bit into their own includes, so that when you edit a schema, it doesnt make a massive recompile
* put schemas into namespaces or something, to prevent name collision and reduce global namespace pollution!
* log error if model load fails
* log error if "connectToSector" is given but it can't be found (same for other connect to stuff)
* find a better way to enforce / handle sectors needing 6 planes, than doing an assert (error / skip?)
 * maybe also let the schema define a min and max size for the array so data parsing can catch it?
* make the game generate documentation of data schemas -> for map files, gfx settings and game data
* what to do about portal window setting for dest->src connection? need to do something... not doing the right thing currently
* in connect tags, assert that the sectors can be found and that the plane indices are valid
* assert that ConeAttenuationAngle <= ConeAngle in point lights (or log an error)
* make graphics settings load more forgiving of load failure (currently sets resolution to 0,0). doesnt use xml defaults, but it probly should!
 * same with game data
* make graphics settings xml file generate if it doesn't exist
 * same for game data xml file
* nake a "connect" tag at the global level

--GFX SETTINGS
* gamma setting
* move default map from gfx settings to game data
* graphics settings to allow reflection and refraction or not. With it off, reflection does nothing, and refraction doesn't change path of ray (so it's just transparent)
* put m_viewWidthHeightDistance etc into graphics settings
* let maps turn off gfx settings.  AKA if a map doesn't have any refraction, no need to test for it so turn off the setting.
* maybe sometime if a texture is lower resolution that our texture setting (like if it's 256x256 and our texture size is 512x512) we can put multiple onto one sheet somehow?  texture coordinates would need to be fixed up somehow
* full screen option in graphics settings
* figure out a decent number to choose for max textures, or make it dynamic in the future or something?
* graphics setting for whether to use mips for textures or not? currently no mipmaps used
* graphics option for vsync.  if vsync is on, it will pass (1, 0) to  m_pSwapChain->Present
* use +/- buttons to increase and decrease render quality (actually maybe just do low, med, high since it needs to recompile the kernel code for each one!)
* make the max # of textures be a graphics setting?
* if no reflection or refraction from #define settings, remove loop completely?  Optimization for low end machines. what about doing transparency without refraction?
* have some way to do autodetection of graphics settings?
* have a way to return values from kernel code - like max color so we can have a compressor on the brightness
* be able to specify texture lookup mode in material? like clamp, repeat, mirror repeat, etc?

--GAME SETTINGS
* mouse sensitivity / invert mouse settings


--DEBUGGING
* can we make a debug visualization for...
 * time taken to render a pixel
 * number of object (triangle?) tests per pixel
* we could have actual debugging metrics for the ray that is under the mouse cursor if we want

--DATA SCHEMAS
* make hints generate into a file somewhere or something...including systems!
* add hints to everything
* verify hint comment that triangle points are assumed to be in clockwise order
* ConnectToSectorOffset, ConnectToPosition -> better explaination hint text
* "packed files" for faster loading.  with a local compile cache or something
* make it error when an id is not found, that is referenced from data.
* make a templated data link type class
* make Field_Schema default work for more than just xml loading.
* C# property grid for generic data editor?
* make the game spit out documentation for the schema files (put hint text into schema and field definitions)
 * maybe done via generic xslt script or something, so other things can tie into it too?
* data parenting support.  "my parent is this, so use everything from him, and over-ride with these values i specify!"
* include file support - so levels can include common files for areas / the entire game

--KERNEL CODE
* instead of kernel code checking for indices being in range, going to make it the responsibility of the CPU to not pass bad data. more dangerous but less kernel code & memory usage etc


--ANALYTICS
* have it record data and be able to view a replay?  Good for analytics & watching what players do.
* have it keep track of health and other things at various points so can graph it on different axes
* could also tie this feature into video recording.

--CODE
* exporter for levels! from unity perhaps?
* investigate the other editors in blender -> such as node editor and graph editor
* hide the console window somehow?
* find a way to make GetSectorPlaneNormal (and similar functions) only implemented in 1 place, instead of once in kernel and once in host
* name the materials from models something deterministic like __<modelid><objectid> so they can be used outside of the models if wanted
* don't let anything be loaded during the levels. When spawning models for instance use a model id.
* be able to choose what format we save screenshots for video like bmp, png, jpg
* write all screenshots for video to a single file like sc2 does? might help w/ disk i/o issues
* maybe allow people to specify the path to save videos to, so that they can put it off their main drive?
* assert that model instance scale is not zero since we have to divide by it!
* assert that a model can be loaded & can be found when instanced from ID
* make a constant for the invalid portal index (and invalid material index?) instead of using -1 in places
* make fatal assert vs regular assert vs log vs verify / validate
 * regular assert brings up a dialog "continue, break, ignore"
 * fatal assert does a divide by zero
 * log relevant info for both assert types
 * give the code a treatment pass for this stuff
* put the matrix math stuff into it's own namespace or something
* texture manager likely doesn't need STexture2d struct since it doesn't use a lot of the fields
 * similar for cdirectx....
* load images in another thread or something?
* make it so we don't update the global root each frame, only when the data actually changes.  That will keep it "cleaner" more often hopefully.
 * maybe have a shared object struct where things are updated every frame (like, camera position) and another where things are seldom changed?
* #pragma warning ( disable : 4005 ) // fix this eventually
* is it better to send the shared data root to kernel as a pointer?
* some command to reload a map file? (like, pressing R?) for faster iteration
* handle the warnings under the code analasys option under the build menu
* improve the video recording quality for youtube usage
* make the recorded video frame rate be specified in data somewhere
* if the window doesn't have focus, i think we shoudl make it sleep (multiplayer?) or just not do rendering (as often?) or something.  it eats up a ton of cpu otherwise
* should we prevent the issue of moving diagonally being faster?
* should there be so many static classes? i kinda think not, or they should have real singleton interfaces
* make asserts show their failed assert? (can do #x in a printf maybe?)
* should we abstract a hotkey system?  we should properly "refcount" key downs and ups, but key repeat kinda screws that up so need to figure that out.
* if needed, could break code up into multiple projects to help compile time if it ends up being an issue
* CDirectX.cpp / .h needs some cleaning up
* if making a data catalog, allow it to be used for network messages as well
* make a way (a script for example) to make a publishable build (grabs exe, shared code, kernel code, etc and puts into some folder and possibly zips it up or whatever?)
* some way to trigger a map reload (need a console?)
* verify material index is in range before indexing in kernel somehow.  maybe have material zero be the default / error material?
* do something to make kernel code build errors more obvious, since it exits now before you can read it. like sscanf on build error or something? idk
* put asserts where needed
* alt+enter full screen toggle (or at least graphics option)
* better app title for window?
* test device lost if still relevant
* can we do any cpu stuff while waiting on gpu?
* quaternion camera?  polar coordinate camera may actually be enough.  quaternion would only be needed for flight controls etc
* attempt to run it on cpu only? might be super super slow, but may be ok at low resolutions and graphics settings?
* async build of cl scripts... you pass a function pointer to clBuildProgram, it will do this
* oclCheckErrorEX <-- go away!!
* can we hide kernelcode/shared include files in the exe or encrypt somehow or something?


--OPENCL INVESTIGATION
? speed of __constant vs __global space
* be able to get info back about the ray under the mouse cursor for debugging?
* look into attribute reqd_work_group_size attribute, since it's known at runtime anyways.  apparently some optimizations can be done if this is used
* GetAndUpdateCLMem vs GetAndUpdateMem.  make it consistent
* maybe make a template param (or something) for shared objects whether they need to be read or readwrite?
* reading data from a shared object blocks.  maybe need to make a way where the read won't block, until someone actually does a GetObject or something?
* could pass a random number, or hash of all relevant files, to the CL compiler as a #define, so it would recompile when needed
* is there a limit to what can be sent to the kernel as arguments? max size or max count?
* there is some way to get the capabilities of the system, we should probably use that to verify the things we are doing are ok
* if you change compile defines, will it recompile the script? it better!
* how do you profile opencl?
* review the querying and creation of opencl platforms, devices and contexts
 * make sure doing right and taking advantage of all options.  probably want a graphics option to choose device!
* see how to get CPU involved.  Maybe having it help would be useful too? dunno.
 * maybe end user can choose device it runs on somehow...
* is it running in SLI? how can i check


--BUGS
* mouse input doesnt work in 64 bit build
* build warning about: c:\program files (x86)\microsoft directx sdk (june 2010)\include\dxgitype.h(12): warning C4005: 'DXGI_STATUS_OCCLUDED' : macro redefinition

--PROFILING
* can you somehow precompile kernel so you dont have to worry about packing and paddnig and shit?
 * appaerntly yes, but it makes it too device specific.  investigate
* make a way to show how many ray bounces per pixel for profiling purposes
* also show how many object tests per pixel (whiter dots = more)


--MODELS
* animated meshes: Have it make bsp trees for each pose?


--LUA
* lua binding so can use this thing from lua and make lots of diff games.
 * is there a way to protect the lua / opencl or embed it into the exe or something?
 * lua swig or lua bind (bind not as good apparently)




=====PERF NOTE=====
* "interlaced mode" helps perf a lot
* turning shadows off helps a lot
* complex models not having shadows

=====RAYTRACING NOTES=====

* Apparently in RT, high level of detail is ok, so long as it doesnt take up a lot of the screen.  AKA small or distance detailed objects are just fine, since not many rays have to calculate collison with them (?)
* some simple/cheap effects in rasterization - like distance or height fog - are more challenging in RT.  Those particular fog features may have been made worse by how i'm iteratively rendering pixel color.

=====OPENCL NOTES=====
? is there an instruction limit in opencl?
 * not really but you dont want to make it too large since the instruction cache is like 64KB usually.
 * http://devgurus.amd.com/thread/158542

* clBuildProgram notes (includes, optimizations, etc)
 http://www.khronos.org/registry/cl/sdk/1.0/docs/man/xhtml/clBuildProgram.html

* it doesn't seem to recompile the cl program unless you modify the cl itself, you can't just edit a header it includes and expect it to recompile! (shitty).
 * also, it doesn't go off timestamp, but actual changes, so you literally need to add a new blank line or something for it to recompile

* when packing a 3 vector and a scalar into a float4 be careful... operations on the 3 vector will overwrite w! you have to do it like this below.  may not be particularly safe... but it does pack things tighter, so tough to say we shouldn't do it at all
 (*(float3*)&info->m_intersectionPointAndTime) = rayPos + rayDir * collisionTime;
 info->m_intersectionPointAndTime.w = collisionTime;

* opencl notes __constant has 64Kb limit and is cached but is global mem. __global higher limits
 * this seems due to it priming a cache with the data or something.
 * people say __constant is faster than __global.  I haven't profiled, but it seems comparable in my usage cases
 * had to switch model triangle list from constant to global because i was hit with a 512 total triangle limit - ouch!

* could use address of primitive instead of having to have an ID per primitive
 * no - for some reason when i did that it went from 400fps down to about 70fps.  no idea why

* RT Basics Done
 * shadows
 * sphere primitives
 * specular lighting
 * diffuse lighting
 * ambient lighting
 * point light
 * box primitives
 * reflection
 * max raybounces
 * refraction

=====NOT DOING=====
*  Video cards / OpenCL support
 * Mike: NVIDIA geforce GT, 2gb mem
 * Eric: Amd but josh and Matthew have nvidia and I have physx card.  we have hd7950 a 470 gtx and a 480 gtx
 * Katie: going to test her 2 cards

TO "SHIP" TO TEAM
* give people access to the git repository and instructions on how to use it
* get people to try the exe

? could just load obj files to avoid dealing with exporter complexity, and tying us to blender
 * obj doesn't do skeletal animations
 * i don't want to deal with other formats :/

* move portal and shadow information off of triangle, onto the model object?
 * actually maybe not.  it's quicker access (memory cache friendly) to have it on the object

 * try better bounding sphere calculations? (find the smallest bounding sphere) Probly not worth it, expensive to find for animated meshes?

* might be able to get around having to pass materials, num materials etc everywhere in kernel by having "private" space vars in program scope?
 * looked into it, limitations to the language make it shitty (program scope vars must be __constant etc)


=====DONE=====

--9/3/14
* working on physics stuff more. swept cylinder vs sector test works and cylinder sliding.
 * need to traverse portals and handle the cylinder being in multiple sectors at once.
* made camera min/max pitch be in the game data for the component.

--9/1/14
* checked in progress up to this point
* camera and movement are in ECS system now.

--8/20/14
* cutting out camera functionality from camera, player, input, etc, putting it into ECS system.

--8/11/14
* at siggraph!
* doing sRGB conversion and taking before and after screenshots
* making X take a screenshot, like how Z toggles video recording

--6/23/14
* made window be the correct size.
* over last couple days learned about integrals and got analytic fog density shadertoy demos working.

--6/18/14
* gdi screen cap work real quick.

--6/15/14
* ESC work -> a player entity, which is defined in data, is now created after game data loading.
* proper components are created for it and it's registered with the appropriate systems.
* the systems get update calls and end up calling update on the player entity, with the appropriate components passed in.

--6/14/14
* worked on fog on and off over the last couple days.
* started working on ECS and started thinking about ECS

--6/8/14
* make kernel arguments be const pointers
* made model instances be able to specify a portal index
* started getting error material in.  works except ship model seems to have adopted it!

--6/7/14 (ish)
* got better fog implemented and checked in.

--6/4/14
* constant density fog plane implementation

--6/2/14
* fixed refraction
* made a color stack in support of fog
* implemented distance fog

--5/31/14
* fixed u,v texture export / importing!
* made a triangle debug visualization gfx setting

--5/30/14
* models are now instanced correctly - they share triangles even when in different locations.
* material override works for instances
* made it so you can scale model instances, cleaned up instance collision code.
* gave treatment to shadows and regular rendering

--5/29/14
* made models load materials from their model files.
* allow a material override for models in the level when specifying a model to load
* added a m_debugAdditiveColor to collision info to aid in debugging things visually
 * added some gfx settings for debugging visually:
  * texture coordinates
  * ray bounce per pixel
  * bounding spheres of models

--5/27/14
* fixed the "flipped normals" problem w/ models looks like.  i swapped Y and Z in export matrix, but needed to negate the new Z to make it a proper rotation

--5/24/14
* fixed a problem where 2nd ship specified in level data wasn't getting rendered problery (probly with sorting the triangles, was starting at index 0!!)
* got the y half spaces mesh model optimization in.  looks like a 33% speed up for meshes!! (didnt do a full test in all scenarios, but my test cases show about 33% improvement)

--5/23/14
* playing around with just y axis half space optimization for meshes.  a line segment that is only in negative y half space doesn't need to test agaisnt triangles that are only in positive y half space, etc! (in model's local space of course)
* make fps display also show mspf

--5/22/14
* tried to use "half space flags" in triangles and segment tests, to cull out triangle tests that don't matter.  it was actually slower for some reason!
 * seems to be a memory access thing or something, will try again later.

--5/12/14
* more beers law absorption stuff.

--5/7/14
* fixed beers law absorption stuff!

--5/5/14
* made translation of models work (tentatively).  need better implementation longer term in matrix form to take it in and out of local space

--5/4/14
* Ditched plane and box, and non model triangle support
* organized model stuff to make more sense (triangles -> objects -> model instances)
* Got bounding spheres working for models, nice speed up even with low quality spheres

--5/3/14
* import tangent / bitangent.  normal maps look better now even for cube case which should be equivelant?
* back face culling.  Doesn't seem to affect perf but leaving it.
* made it export from blender (z is up) to my world (y is up) properly.

--4/30/14
* made it so the root transform is applied when exporting
* maed it always export triangles (no quads anymore)

--4/28/14
* texture coordinates exported
* when loading models, faces may have either 3 or 4 verts.  If 4, make 2 triangles!
* need to make it handle non geometric objects when exporting (ignore them!)

--4/27/14
* a basic custom blender model exporter is at version 1 and im loading those models into the game.  needs some work though to support existing features and required model features

--4/13/14
* add texture coordinates to triangles and use that instead of texture scale and stuff
* find a better ray vs triangle test

--4/10/14
* started on triangle support
* been trying to figure out math for curve based surfaces, but didnt find anything reasonable.

--3/3/14
* put in a graphics option for full screen mode

--3/2/14
* put in a graphics setting for texture filtering.  If true, CLK_FILTER_LINEAR is used, else CLK_FILTER_NEAREST is used when sampling textures.

--2/8/14
* brightness setting in gfx setings
* started working on "autoadjust exposure time" stuff

--2/7/14
* added texture offset option
* made skyboxes work!

--2/5/14
* started working on loading models
* made a graphics setting to turn on and off full (unsafe) optimizations.  doesn't seem to make much of a difference for me unfortunately
* implemented pressing shift for sprinting
* put walk speed, walk speed crouch, and sprint speed modifier into game data.

--2/4/14
* sector wall portal window tests are done off a constant uv instead of it being tied to texture u axis.
* converted ConnectTo offset to uv space.
* ditched the global connect tag for now in xml.  not needed right now, and would need to convert uv offset (for destination sector wall) to make it work right
* need a setting for eye width in red/blue 3d mode
* max ray bounces setting

--2/3/14
* red/blue 3d mode
* worked on the global connect xml nodes

--2/2/14
* convert testarea.xml to use new connectto feature
* made portalwindow work with connectto stuff, so you can auto connect and still have a custom window

--2/1/14
* the sector plane connect to stuff is seemingly working now
* also have portal window calculations working
* i've been working on those guys for the last week or so :P

--1/27/14
* worked on getting sector plane "connect to" working

--1/26/14
* working on making ConnectToSector stuff work in sector plane definitions
 * pretty close to working... for the "square" room, one link was working, but the other wasn't

--1/25/14
* distance attenuation for lights
* put in real spot light function
* graphics setting to turn off high quality lighting (distance and angular attenuation)

--1/23/14
* camera is transformed by portal when traversing sectors now
* make StartFacing a float3
* make lighting seemless in default.xml

--1/22/14
* seperate maps from settings and game data
* rename sharedmath.h and take it out of the shared folder, since it isnt, and can't be shared

--1/20/14
* made it so you walk through portals to change sectors.  doesnt check against portal windows though
* made a more complex, looping / non realistic infinite map

--1/15/14
* put all geometry into sector definitions.
 * move other geometry types in
 * also point lights
 * ambient light
* might not need "numplanes" etc, if the indices to use are part of sector data

--1/14/14
* put planes into sectors.  will move the rest of geometry types, and give shadow treatment later
* interlaced mode, via graphics setting and #define to kernel code

--1/12/14
* added quad support
* made planes be able to define dimensions -> a min/max u,v to be considered as a hit.  IE quads are supported now
* do compile time const asserts that the size of structs in shared object and shared array are multiples of 16
* portals are now a generic thing that any shape can use, not just sector walls, but sector walls have kept their "portal window" field because it's more efficient than having a seperate plane when a portal is on a sector wall anyways
* basic interlaced mode implementation
* added gfxsettings.xml and gamedata.xml

--1/11/14
* made sectors into AABBs defined by just width, height, depth.  kept per plane material etc.  portals are still a sector wall feature for now but will change soon.

--1/5/14
* started formalizing an ID system for the data catalog.
* started making it so sector walls could be see through & lead to other portals
* enforce unique ids in data items that have ids
* make it so portal walls can define a UV square for the portal, and it uses the material info for the rest of the box.
* make sector walls each have their own id so reflection of sector walls works correctly

--1/4/14
* started working on portal rendering.
* you can define sectors, and the game tells the renderer which sector the camera is in.  it only tests rays against that sector

--12/13/13
* continued work on plane primitive for bsp

--12/12/13
* added plane primitive in preperation of BSP, some work left to do

--12/10/13
* fixed timestep logic - so you dont have times that you can jump higher etc
* made collision info contain surface normal as well as U and V vectors

--11/17/13
* finished getting bump maps working
* got emissive texture working
* make sure all cl_mem objects are getting released properly with clReleaseMemObject

--11/16/13
* been working on textures, got it working as a 3d texture.  textures need to be square, but they are bilinear filtered to the appropriate texture size.

--11/13/13
* got formalized schema based xml parser done... been working on it on and off the last several days
* organized and cleaned up the code a bit
* got jumping and gravity working
* got crouching working
* got video recording and screenshots working

--11/4/13
* command line to load a specific xml scene file so people can make their own maps
* got 64 bit build working, although mouse input doesn't work in debug or release in 64 bit

--11/3/13
* over the weekend learned a ton about matrix math
* got bumpmapping w/ RT working on shadertoy.  looks amazing combined with refraction
* got code into git

--10/29/13
* got most of xml scene loading working

--10/26/13
* got shadows working
* only shadow test objects marked as casting shadows
* move ambient lighting to be a c++ param
* make the light spheres use a material that is their color
* use constant instaead of global space
* combine color and amount, pos and radius etc.  use swizzle to get just the components you want.  shared geometry / smaterial
* make sure all params are out of the kernel code

--10/25/13
* made more objects be passed through from c++ side
* made materials be a set of objects indexed by prims
* fought w/ padding and alignment w/ shared structs working for now (need to formalize it later to be not manual)
* make some kind of shadowed object array to make it easier to send objects to the cl file.

--10/21/13
* swept the crash on exit under the rug by not dynamically unlinking dx10 at exit.  todo for later :/
* lights now get passed through dynamically from cpp

--10/20/13
* got a basic camera in as a shared struct passed to the kernal
* got some spheres with specular, diffuse and ambient lighting in.  got a point light in
* got wasd movement and mouse look in
* axis aligned box support
* reflection / refraction
* got rid of nvidia extensions in favor of khr extensions of the same name

--10/19/13
* figured out how includes and defines worked in .cl program compiling
* cpu gives camera pos, fwd, up and other info and passes it to cl to make into rays.

--9/22/13
* Get opencl compiling and running
* started cleaning up and renaming things
